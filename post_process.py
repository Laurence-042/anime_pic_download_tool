"""
Post-processing module for downloaded images.
Detects ComfyUI generated images and renames them accordingly.
"""

import os
import re
from typing import Optional
from PIL import Image


def is_comfy_image(file_path: str) -> bool:
    """
    Check if a PNG image was generated by ComfyUI.
    ComfyUI embeds workflow/prompt data in PNG metadata.
    
    Args:
        file_path: Path to the PNG file
        
    Returns:
        True if the image has ComfyUI metadata
    """
    if not file_path.lower().endswith('.png'):
        return False
    
    try:
        with Image.open(file_path) as img:
            # Verify it's a valid image
            img.verify()
    except Exception:
        # Cannot read or verify image, skip silently
        return False
    
    try:
        # Need to reopen after verify()
        with Image.open(file_path) as img:
            # ComfyUI stores data in PNG text chunks
            # Common keys: "prompt", "workflow"
            metadata = img.info
            
            # Check for ComfyUI specific metadata keys
            if 'prompt' in metadata or 'workflow' in metadata:
                return True
            
            # Some ComfyUI outputs may have different key names
            for key in metadata:
                value = str(metadata[key])
                # Check for ComfyUI workflow patterns
                if '"class_type"' in value or '"inputs"' in value:
                    return True
                    
    except Exception:
        # Failed to read metadata, skip silently
        return False
    
    return False


def get_comfy_filename(original_path: str) -> str:
    """
    Generate the new filename with .comfy suffix.
    Example: image.png -> image.comfy.png
    
    Args:
        original_path: Original file path
        
    Returns:
        New file path with .comfy suffix
    """
    # Handle already renamed files
    if '.comfy.png' in original_path.lower():
        return original_path
    
    # Split path and extension
    base, ext = os.path.splitext(original_path)
    return f"{base}.comfy{ext}"


def process_image(file_path: str, dry_run: bool = False) -> Optional[str]:
    """
    Process a single image file. Renames to .comfy.png if ComfyUI detected.
    
    Args:
        file_path: Path to the image file
        dry_run: If True, only report what would be done without renaming
        
    Returns:
        New file path if renamed, None otherwise
    """
    if not os.path.exists(file_path):
        return None
    
    # Skip already processed files
    if '.comfy.png' in file_path.lower():
        return None
    
    if not is_comfy_image(file_path):
        return None
    
    new_path = get_comfy_filename(file_path)
    
    if dry_run:
        print(f"[DRY RUN] Would rename: {file_path} -> {new_path}")
        return new_path
    
    try:
        os.rename(file_path, new_path)
        print(f"Renamed: {file_path} -> {os.path.basename(new_path)}")
        return new_path
    except Exception as e:
        print(f"Error renaming {file_path}: {e}")
        return None


def process_directory(directory: str, recursive: bool = True, dry_run: bool = False) -> dict:
    """
    Process all PNG files in a directory.
    
    Args:
        directory: Directory path to scan
        recursive: If True, scan subdirectories as well
        dry_run: If True, only report what would be done
        
    Returns:
        Dictionary with statistics: {total, processed, renamed, errors}
    """
    stats = {
        'total': 0,
        'processed': 0,
        'renamed': 0,
        'errors': 0
    }
    
    if not os.path.isdir(directory):
        print(f"Error: {directory} is not a valid directory")
        return stats
    
    # Walk through directory
    if recursive:
        file_iterator = (
            os.path.join(root, file)
            for root, dirs, files in os.walk(directory)
            for file in files
        )
    else:
        file_iterator = (
            os.path.join(directory, f)
            for f in os.listdir(directory)
            if os.path.isfile(os.path.join(directory, f))
        )
    
    for file_path in file_iterator:
        if not file_path.lower().endswith('.png'):
            continue
        
        # Skip already processed files
        if '.comfy.png' in file_path.lower():
            continue
            
        stats['total'] += 1
        
        try:
            result = process_image(file_path, dry_run)
            stats['processed'] += 1
            if result:
                stats['renamed'] += 1
        except Exception as e:
            print(f"Error processing {file_path}: {e}")
            stats['errors'] += 1
    
    return stats


def post_process_downloaded_file(file_path: str) -> str:
    """
    Post-process a newly downloaded file.
    This function is called by the downloader after each file is saved.
    
    Args:
        file_path: Path to the downloaded file
        
    Returns:
        The final file path (may be renamed)
    """
    if not file_path.lower().endswith('.png'):
        return file_path
    
    new_path = process_image(file_path)
    return new_path if new_path else file_path
